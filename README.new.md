# 说明

> 本文为 Steins; Gate 第零届 PKU HPCGame DEM 赛题 writeup，此文由本团队原创。

## 运行说明

- 本程序使用 Julia 语言编写，在 Julia 1.9.0-beta.3 版本下进行了测试。
- 在 HPC 上运行的脚本已经写在 `Makefile` 中，可以直接使用 `make hpc` 命令来配置环境并运行程序。

## 关键优化

原程序都是按照颗粒来并行计算的，但颗粒之间的接触数可能有很大的差别，这就造成了运行时间的浪费。在我们的这一优化实现中，对两个关键步骤的并行方式进行了改进：

- 在遍历宽检测结果（也即 `cp_list`）时，直接对每一个宽检测的颗粒对进行并行计算。原程序中只保存了颗粒对的 `j`，这里因为我们不再对颗粒进行并行，所以需要在 `cp_list` 中同时保存颗粒对的 `i`，也即 `cp_list` 中的每一项变为了一个二元组，分别保存 `i` 和 `j`。
- 在遍历接触时，对每一个接触进行并行计算。这里的改动较大。原程序相当于是用一个二维数组来保存接触，从而实现颗粒级别的并行。这里我们将其改为了一维数组，用一个指针来维护当前的偏置，在遍历宽检测结果时，用原子操作更新这一指针，从而得到一个不包含空隙的接触数组，以便进行并行计算。
  - 接触的 `active` 和 `bonded` 状态各使用一个全局的 `BitTable` 来维护。
  - 在每一时间步的最后，清理无效接触时，我们采用了滚动数组的方法。原接触对保存在 `contacts` 中，同时有一个临时数组 `contacts_temp`。采用与前面类似的方法，用一个指针维护临时数组当前的偏置，用原子操作更新指针，并行将仍然有效的接触复制到临时数组中。最后将 `contacts` 和 `contacts_temp` 交换，这样就完成了清理。

## 其他差异

- `CUDA.jl` 支持直接对数组进行并行的 `accumulate`，不需要自行实现并行前缀和。
- `Mortan.jl` 计算结果遵循了 Julia 下标从 `1` 开始的规范。因此 `cartesian3mortan([2,3,4])` 的结果等于原版的 `mortan3d32(1, 2, 3) + 1`。
